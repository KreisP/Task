#lang sicp

;Упражнение 1.1

10

(+ 5 3 4)

(- 9 1)

(/ 6 2)

(+ (* 2 4) (- 4 6))

(define a 3)

(define b (+ a 1))

(+ a b (* a b))

(= a b)

(if (and (> b a) (< b (* a b)))
    b
    a)

(cond ((= a 4) 6)
    ((= b 4) (+ 6 7 a))
    (else 25))

(+ 2 (if (> b a ) b a))

(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
    (+ a 1))

 
;Упражнение 1.2

(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))

;Упражнение 1.3
(define (sum-of-square x y) (+ (* x x) (* y y)))

(define (sum-of-square-largest x y z)
    (cond ((and (< x y) (< x z)) (sum-of-square y z))
            ((and (< y x) (< y z)) (sum-of-square x z))
            ((and (< z x) (< z y)) (sum-of-square x y))))

(sum-of-square-largest 1 2 3)

;Упражнение 1.4
#|
Конструкция if осуществляет контроль знака операнда, который должен использоваться по модулю (b).
Если операнд положительный - он складывается.
Если операнд отрицательный - он вычитается, а так как вычитание отрицательного числа дает нам сложение,
то мы всегда использвуем операнд b по модулю (abc).
|#

;Упражнние 1.5
#|
Если интерпретатор использует аппликативный порядок вычислений, то перед тем как приступить к
вычислению функции test, он сначала вычислит значения всех её аргументов, в том числе и функции
p. Функция p - рекурсивная и не имеет условия выхода из рекурсивного цикла, что при её вычислении
приведет к ошибке интерпретатора, и функция test-eval-order не будет вычислена. В случае же
нормального порядка вычислений, аргументы функции не вычисляются до момента их непосредственного
использования. Таким образом при вычислении функции test-eval-order с заданными параметрами, 
функция p не будет вычислена, так как не учавствует в конечных вычислениях.
|#